好的，我们现在就开始。为了确保你能稳拿高分，我们将开发过程拆解为 \*\*5 个具体的阶段\*\*。我们先从\*\*第一阶段：环境搭建与基础设施\*\*开始。



\[cite\_start]这一步非常关键，因为“评分标准”明确要求了 Git 提交记录 \[cite: 260]\[cite\_start]、AI 日志 \[cite: 169] \[cite\_start]以及严格的资源管理 (RAII) \[cite: 169]。打好基础可以避免后期重构。



-----好的，我们现在就开始。为了确保你能稳拿高分，我们将开发过程拆解为 \*\*5 个具体的阶段\*\*。我们先从\*\*第一阶段：环境搭建与基础设施\*\*开始。



\[cite\_start]这一步非常关键，因为“评分标准”明确要求了 Git 提交记录 \[cite: 260]\[cite\_start]、AI 日志 \[cite: 169] \[cite\_start]以及严格的资源管理 (RAII) \[cite: 169]。打好基础可以避免后期重构。



---



\### 🗺️ 开发路线图 (Roadmap)



  \* \*\*阶段 1：环境搭建与基础设施 (当前步骤)\*\* —— \*Git, MFC工程, RAII资源封装\*

  \* 阶段 2：双缓冲画布与基础交互 —— \*无闪烁绘图, 鼠标消息处理\*

  \* 阶段 3：架构核心实现 (Factory \& Strategy) —— \*图形工厂, 渲染策略\*

  \* 阶段 4：撤销/重做系统 (Command) —— \*命令模式实现\*

  \* 阶段 5：测试与文档 —— \*GoogleTest, AI日志完善\*



---



\### 🚀 阶段 1：环境搭建与基础设施



\#### 步骤 1.1：初始化 Git 仓库



\[cite\_start]根据文档要求，你需要向老师报告小组的 Git 地址 \[cite: 260]。



1\.  在本地新建文件夹 `SimpleDrawBoard`。

2\.  打开终端（CMD/PowerShell）执行：

    ```bash

    git init

    # 创建 .gitignore 文件，排除 VS 临时文件 (如 .vs, \*.obj, \*.pch, \*.pdb)

    ```

3\.  \[cite\_start]\*\*AI 合规提示\*\*：从现在开始，任何 AI 生成的代码都要记录 Prompt。在项目根目录创建 `docs/ai\\\_logs/` 文件夹 \[cite: 131]。



\#### 步骤 1.2：创建 MFC 项目



\[cite\_start]根据非功能需求 NF-01 \[cite: 177]：



1\.  打开 \*\*Visual Studio 2022\*\*。

2\.  创建新项目 -\\> 搜索 \*\*"MFC 应用"\*\*。

3\.  \*\*项目名称\*\*：`SimpleDrawBoard`。

4\.  \*\*应用程序类型\*\*：

      \* 选择 \*\*单文档 (Single Document)\*\* 或 \*\*多文档 (Multiple Documents)\*\*。\*建议选单文档 (SDI) 配合拆分窗口，或者选多文档 (MDI) 符合项目1的架构复用，但项目2主要考察绘图，SDI 结构最简单。为了稳妥，选 \*\*单文档\*\* 且 \*\*取消勾选 "文档/视图架构支持"\*\* (如果想极简)；或者 \*\*保留 "文档/视图架构支持"\*\* (推荐，方便后续做 Undo/Redo 数据管理)\*。

      \* \*\*项目样式\*\*：Visual Studio (或 Windows 原生)。

      \* \*\*高级功能\*\*：取消勾选“ActiveX”、“公共控件清单”以外的不必要选项以减小体积。



\#### 步骤 1.3：实现 RAII GDI 包装类 (核心得分点)



\[cite\_start]根据功能 F-07 和 F-08，必须使用 \*\*RAII (Resource Acquisition Is Initialization)\*\* 包装 GDI 对象，防止内存泄漏 \[cite: 169, 177]\[cite\_start]。这是代码审查的重点 \[cite: 154]。



\*\*任务\*\*：在项目中添加一个新类 `CGdiObjectWrapper.h`。



\*\*你可以直接使用下面的代码结构（请手动输入或理解后修改，不要直接复制粘贴以免违反 AI 也就是我的使用日志要求）：\*\*



```cpp

// CGdiObjectWrapper.h

\\#pragma once

\\#include <afxwin.h>



// 这是一个模板类，用于自动管理 GDI 对象（画笔、画刷等）的生命周期

\\\[cite\\\_start]// 对应评分标准：目标3 - 资源泄漏、异常安全 \\\[cite: 59, 169]



template <typename T>

class CGdiObjectWrapper {

public:

\&nbsp;   // 构造函数：接受现有的指针或为空

\&nbsp;   explicit CGdiObjectWrapper(T\\\* pObject = nullptr) : m\\\_pObject(pObject) {}



\&nbsp;   // 析构函数：核心！自动删除对象

\&nbsp;   ~CGdiObjectWrapper() {

\&nbsp;       Release();

\&nbsp;   }



\&nbsp;   // 禁止复制（防止两个 Wrapper 删除同一个对象），但在 C++11 后可支持移动

\&nbsp;   CGdiObjectWrapper(const CGdiObjectWrapper\\\&) = delete;

\&nbsp;   CGdiObjectWrapper\\\& operator=(const CGdiObjectWrapper\\\&) = delete;



\&nbsp;   // 允许移动语义 (Move Semantics)

\&nbsp;   CGdiObjectWrapper(CGdiObjectWrapper\\\&\\\& other) noexcept : m\\\_pObject(other.m\\\_pObject) {

\&nbsp;       other.m\\\_pObject = nullptr;

\&nbsp;   }



\&nbsp;   CGdiObjectWrapper\\\& operator=(CGdiObjectWrapper\\\&\\\& other) noexcept {

\&nbsp;       if (this != \\\&other) {

\&nbsp;           Release();

\&nbsp;           m\\\_pObject = other.m\\\_pObject;

\&nbsp;           other.m\\\_pObject = nullptr;

\&nbsp;       }

\&nbsp;       return \\\*this;

\&nbsp;   }



\&nbsp;   // 创建画笔的辅助函数

\&nbsp;   bool CreatePen(int nPenStyle, int nWidth, COLORREF crColor) {

\&nbsp;       Release();

\&nbsp;       m\\\_pObject = new CPen(); 

\&nbsp;       if (!m\\\_pObject->CreatePen(nPenStyle, nWidth, crColor)) {

\&nbsp;           delete m\\\_pObject;

\&nbsp;           m\\\_pObject = nullptr;

\&nbsp;           return false;

\&nbsp;       }

\&nbsp;       return true;

\&nbsp;   }

\&nbsp;   

\&nbsp;   // 获取原始指针用于 MFC 函数调用

\&nbsp;   T\\\* Get() const { return m\\\_pObject; }

\&nbsp;   

\&nbsp;   // 重载 -> 操作符，使其像指针一样使用

\&nbsp;   T\\\* operator->() const { return m\\\_pObject; }



private:

\&nbsp;   void Release() {

\&nbsp;       if (m\\\_pObject) {

\&nbsp;           m\\\_pObject->DeleteObject(); // 删除 GDI 句柄

\&nbsp;           delete m\\\_pObject;          // 删除 C++ 对象

\&nbsp;           m\\\_pObject = nullptr;

\&nbsp;       }

\&nbsp;   }



\&nbsp;   T\\\* m\\\_pObject;

};



// 使用别名方便调用

using CPenWrapper = CGdiObjectWrapper<CPen>;

using CBrushWrapper = CGdiObjectWrapper<CBrush>;

```



\#### 步骤 1.4：验证环境



1\.  编译项目 (Ctrl + Shift + B)。确保 0 错误 0 警告。

2\.  运行项目，确保能看到一个空白窗口。

3\.  \*\*提交代码到 Git\*\*：

    ```bash

    git add .

    git commit -m "Initial commit: Project structure and RAII wrapper setup"

    ```

4\.  \*\*记录 AI 日志\*\*：

    \[cite\_start]在 `docs/ai\\\_logs/` 下创建一个 Markdown 文件（例如 `2025-12-04\\\_setup.md`），记录你刚才可能询问了 AI “如何实现 C++ RAII 模板类”，并粘贴上面的代码作为 Response \[cite: 130]。



---



\*\*✅ 阶段 1 完成。\*\*



\*\*👉 下一步指令：\*\*

是否已完成上述设置？如果是，请回复 \*\*“完成”\*\*，我们将进入 \*\*阶段 2：双缓冲画布与基础交互\*\*。这一步我们将解决最核心的“闪烁”问题并画出第一条线。



\### 🗺️ 开发路线图 (Roadmap)



  \* \*\*阶段 1：环境搭建与基础设施 (当前步骤)\*\* —— \*Git, MFC工程, RAII资源封装\*

  \* 阶段 2：双缓冲画布与基础交互 —— \*无闪烁绘图, 鼠标消息处理\*

  \* 阶段 3：架构核心实现 (Factory \& Strategy) —— \*图形工厂, 渲染策略\*

  \* 阶段 4：撤销/重做系统 (Command) —— \*命令模式实现\*

  \* 阶段 5：测试与文档 —— \*GoogleTest, AI日志完善\*



---



\### 🚀 阶段 1：环境搭建与基础设施



\#### 步骤 1.1：初始化 Git 仓库



\[cite\_start]根据文档要求，你需要向老师报告小组的 Git 地址 \[cite: 260]。



1\.  在本地新建文件夹 `SimpleDrawBoard`。

2\.  打开终端（CMD/PowerShell）执行：

    ```bash

    git init

    # 创建 .gitignore 文件，排除 VS 临时文件 (如 .vs, \*.obj, \*.pch, \*.pdb)

    ```

3\.  \[cite\_start]\*\*AI 合规提示\*\*：从现在开始，任何 AI 生成的代码都要记录 Prompt。在项目根目录创建 `docs/ai\\\_logs/` 文件夹 \[cite: 131]。



\#### 步骤 1.2：创建 MFC 项目



\[cite\_start]根据非功能需求 NF-01 \[cite: 177]：



1\.  打开 \*\*Visual Studio 2022\*\*。

2\.  创建新项目 -\\> 搜索 \*\*"MFC 应用"\*\*。

3\.  \*\*项目名称\*\*：`SimpleDrawBoard`。

4\.  \*\*应用程序类型\*\*：

      \* 选择 \*\*单文档 (Single Document)\*\* 或 \*\*多文档 (Multiple Documents)\*\*。\*建议选单文档 (SDI) 配合拆分窗口，或者选多文档 (MDI) 符合项目1的架构复用，但项目2主要考察绘图，SDI 结构最简单。为了稳妥，选 \*\*单文档\*\* 且 \*\*取消勾选 "文档/视图架构支持"\*\* (如果想极简)；或者 \*\*保留 "文档/视图架构支持"\*\* (推荐，方便后续做 Undo/Redo 数据管理)\*。

      \* \*\*项目样式\*\*：Visual Studio (或 Windows 原生)。

      \* \*\*高级功能\*\*：取消勾选“ActiveX”、“公共控件清单”以外的不必要选项以减小体积。



\#### 步骤 1.3：实现 RAII GDI 包装类 (核心得分点)



\[cite\_start]根据功能 F-07 和 F-08，必须使用 \*\*RAII (Resource Acquisition Is Initialization)\*\* 包装 GDI 对象，防止内存泄漏 \[cite: 169, 177]\[cite\_start]。这是代码审查的重点 \[cite: 154]。



\*\*任务\*\*：在项目中添加一个新类 `CGdiObjectWrapper.h`。



\*\*你可以直接使用下面的代码结构（请手动输入或理解后修改，不要直接复制粘贴以免违反 AI 也就是我的使用日志要求）：\*\*



```cpp

// CGdiObjectWrapper.h

\\#pragma once

\\#include <afxwin.h>



// 这是一个模板类，用于自动管理 GDI 对象（画笔、画刷等）的生命周期

\\\[cite\\\_start]// 对应评分标准：目标3 - 资源泄漏、异常安全 \\\[cite: 59, 169]



template <typename T>

class CGdiObjectWrapper {

public:

\&nbsp;   // 构造函数：接受现有的指针或为空

\&nbsp;   explicit CGdiObjectWrapper(T\\\* pObject = nullptr) : m\\\_pObject(pObject) {}



\&nbsp;   // 析构函数：核心！自动删除对象

\&nbsp;   ~CGdiObjectWrapper() {

\&nbsp;       Release();

\&nbsp;   }



\&nbsp;   // 禁止复制（防止两个 Wrapper 删除同一个对象），但在 C++11 后可支持移动

\&nbsp;   CGdiObjectWrapper(const CGdiObjectWrapper\\\&) = delete;

\&nbsp;   CGdiObjectWrapper\\\& operator=(const CGdiObjectWrapper\\\&) = delete;



\&nbsp;   // 允许移动语义 (Move Semantics)

\&nbsp;   CGdiObjectWrapper(CGdiObjectWrapper\\\&\\\& other) noexcept : m\\\_pObject(other.m\\\_pObject) {

\&nbsp;       other.m\\\_pObject = nullptr;

\&nbsp;   }



\&nbsp;   CGdiObjectWrapper\\\& operator=(CGdiObjectWrapper\\\&\\\& other) noexcept {

\&nbsp;       if (this != \\\&other) {

\&nbsp;           Release();

\&nbsp;           m\\\_pObject = other.m\\\_pObject;

\&nbsp;           other.m\\\_pObject = nullptr;

\&nbsp;       }

\&nbsp;       return \\\*this;

\&nbsp;   }



\&nbsp;   // 创建画笔的辅助函数

\&nbsp;   bool CreatePen(int nPenStyle, int nWidth, COLORREF crColor) {

\&nbsp;       Release();

\&nbsp;       m\\\_pObject = new CPen(); 

\&nbsp;       if (!m\\\_pObject->CreatePen(nPenStyle, nWidth, crColor)) {

\&nbsp;           delete m\\\_pObject;

\&nbsp;           m\\\_pObject = nullptr;

\&nbsp;           return false;

\&nbsp;       }

\&nbsp;       return true;

\&nbsp;   }

\&nbsp;   

\&nbsp;   // 获取原始指针用于 MFC 函数调用

\&nbsp;   T\\\* Get() const { return m\\\_pObject; }

\&nbsp;   

\&nbsp;   // 重载 -> 操作符，使其像指针一样使用

\&nbsp;   T\\\* operator->() const { return m\\\_pObject; }



private:

\&nbsp;   void Release() {

\&nbsp;       if (m\\\_pObject) {

\&nbsp;           m\\\_pObject->DeleteObject(); // 删除 GDI 句柄

\&nbsp;           delete m\\\_pObject;          // 删除 C++ 对象

\&nbsp;           m\\\_pObject = nullptr;

\&nbsp;       }

\&nbsp;   }



\&nbsp;   T\\\* m\\\_pObject;

};



// 使用别名方便调用

using CPenWrapper = CGdiObjectWrapper<CPen>;

using CBrushWrapper = CGdiObjectWrapper<CBrush>;

```



\#### 步骤 1.4：验证环境



1\.  编译项目 (Ctrl + Shift + B)。确保 0 错误 0 警告。

2\.  运行项目，确保能看到一个空白窗口。

3\.  \*\*提交代码到 Git\*\*：

    ```bash

    git add .

    git commit -m "Initial commit: Project structure and RAII wrapper setup"

    ```

4\.  \*\*记录 AI 日志\*\*：

    \[cite\_start]在 `docs/ai\\\_logs/` 下创建一个 Markdown 文件（例如 `2025-12-04\\\_setup.md`），记录你刚才可能询问了 AI “如何实现 C++ RAII 模板类”，并粘贴上面的代码作为 Response \[cite: 130]。



---



\*\*✅ 阶段 1 完成。\*\*



\*\*👉 下一步指令：\*\*

是否已完成上述设置？如果是，请回复 \*\*“完成”\*\*，我们将进入 \*\*阶段 2：双缓冲画布与基础交互\*\*。这一步我们将解决最核心的“闪烁”问题并画出第一条线。

