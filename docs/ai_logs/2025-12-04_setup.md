写一个项目2的开发文档

这是一份基于课程讲义为您整理的 **项目 2：简易绘图板开发文档**。这份文档旨在指导开发过程，确保满足所有评分标准，特别是架构设计模式和 AI 规范部分。

---

# 项目 2：简易绘图板 (GDI+撤销/重做) 开发文档

**课程名称**：AI 辅助编程实践
**文档版本**：V1.0


**开发环境**：Windows 10/11 x64, VS2022, MFC 14.x 

---

## 1. 项目概述 (Overview)

本项目旨在开发一个基于 MFC 和 GDI 技术的多文档（或单文档）绘图应用程序。核心目标是练习面向对象设计模式（Factory, Command, Strategy）以及 Windows 图形编程中的资源管理（RAII）。

### 核心功能需求

* 
**绘图工具**：支持直线、矩形、椭圆、自由曲线绘制 。


* 
**交互逻辑**：鼠标左键按下开始，移动预览，松开完成绘制 。


* 
**属性设置**：支持修改颜色、线宽，并在 UI（工具栏/状态栏）显示当前状态 。


* 
**历史记录**：支持多级撤销（Undo）与重做（Redo） 。


* 
**非功能需求**：绘制延迟 \le 30ms，防闪烁，资源无泄漏 。



---

## 2. 系统架构设计 (Architecture)

本项目采用经典的 **MVC (Model-View-Controller)** 变体（MFC Doc/View 架构），并深度结合设计模式以满足教学目标 2 。

### 2.1 类图概览 (Class Structure)

* 
**View 层 (`CMyDrawView`)**: 负责处理鼠标消息 (`OnLButtonDown`, etc.) 和调用绘制接口。需实现**双缓冲 (Double Buffering)** 以防止屏幕闪烁 。


* **Document 层 (`CMyDrawDoc`)**: 维护图形对象列表 (`std::vector<IShape>`) 和撤销/重做栈。
* **Model 层 (`IShape`)**: 所有图形的基类接口。

### 2.2 关键设计模式应用 (Design Patterns)

根据评分标准，必须正确使用以下模式 ：

| 模式 | 应用场景 | 实现细节 |
| --- | --- | --- |
| **Factory** | 图形创建 | 创建 `ShapeFactory` 类。根据用户选择的工具（直线/矩形/椭圆），生产对应的 `IShape` 子类实例。 |
| **Strategy** | 渲染逻辑 | 实现 `IRenderStrategy` 接口。将“怎么画”与“画什么”分离，支持未来扩展不同的渲染风格（如虚线、填充模式）。 |
| **Command** | 撤销/重做 | 每次绘制操作封装为一个 `Command` 对象，压入 `UndoStack`。执行 Undo 时将命令弹出并压入 `RedoStack`。 |
| **RAII** | 资源管理 | 封装 `CGdiObjectWrapper` 类。确保 GDI 句柄（HPEN, HBRUSH）在构造时申请，析构时自动释放，防止 GDI 泄漏 。

 |

---

## 3. 详细功能实现 (Implementation Details)

### 3.1 绘图交互流程 (F-01, F-02)

1. **用户选择工具**：UI 设置当前 `ToolType`。
2. **`OnLButtonDown`**：调用 `ShapeFactory::CreateShape(ToolType)` 创建临时图形对象，记录起点。
3. **`OnMouseMove`**：
* 更新临时图形的终点。
* 触发 `Invalidate()` 重绘。
* 使用双缓冲技术：先在内存 DC (`CMemDC`) 上绘制所有已存图形 + 当前临时图形，最后一次性 BitBlt 到屏幕 。




4. **`OnLButtonUp`**：
* 将临时图形正式加入 Document 的图形列表。
* 
**关键**：创建对应的 `AddShapeCommand` 并推入撤销栈 。





### 3.2 撤销/重做机制 (F-04)

建立两个栈：`std::stack<ICommand*> m_undoStack` 和 `m_redoStack`。

* **ICommand 接口定义**：
```cpp
class ICommand {
public:
    virtual void Execute() = 0; // 执行/重做
    virtual void UnExecute() = 0; // 撤销
};

```


* **操作逻辑**：当用户画了一个矩形，生成一个 `DrawCommand`，其 `Execute` 把矩形加到列表，`UnExecute` 把矩形从列表移除。

### 3.3 资源安全与 RAII (F-07)

**严禁**直接使用原始 GDI 句柄而不释放。

* **错误示例**：`CPen* pPen = new CPen(...)` (如果忘记 delete 会泄漏)。
* **正确实现**：使用智能指针或自定义 Wrapper。
```cpp
// 示例 RAII 包装
class CPenWrapper {
    CPen m_pen;
public:
    CPenWrapper(int style, int width, COLORREF color) { m_pen.CreatePen(style, width, color); }
    ~CPenWrapper() { m_pen.DeleteObject(); } // 自动清理
    operator CPen*() { return &m_pen; }
};

```



---

## 4. 质量保证与测试 (QA & Testing)

### 4.1 单元测试 (F-09)

* 
**工具**：GoogleTest 或 Catch2 。


* 
**覆盖率要求**：> 70% 。


* **测试重点**：
* `ShapeFactory` 是否正确创建了对象。
* `Serializer` (如果实现了文件保存) 是否正确读写。
* `Command` 栈的 Push/Pop 逻辑是否符合预期。



### 4.2 性能指标 (NF-02)

* 使用性能分析工具检测 `OnDraw` 函数。
* 确保绘制延迟 \le 30ms（即帧率 > 33 FPS），复杂图形下不卡顿 。



---

## 5. AI 辅助编程规范 (AI Compliance)

为满足目标 3 和目标 4，必须严格执行以下流程：

1. 
**代码生成声明**：在使用 LLM 生成的任何文件（如 `ShapeFactory.cpp`）头部，必须加入特定的注释声明 。


2. **日志记录**：
* 所有 AI 对话必须记录。
* 
**路径**：`docs/ai_logs/<date>_task_drawing.md` 。


* 
**内容**：必须包含 Prompt（提示词）、Response（回复）、Diff（你修改了什么）。




3. 
**人工审核**：重点检查 AI 生成的代码是否存在 GDI 句柄泄漏（AI 常犯错误），并确保没有硬编码路径 。



---

## 6. 下一步行动计划 (Action Items)

1. **Week 1**: 搭建 MFC 框架，配置 GoogleTest 环境，实现 `CGdiObjectWrapper` (RAII)。
2. **Week 2**: 实现 `ShapeFactory` 和基本图形绘制（直线、矩形），完成双缓冲。
3. **Week 3**: 实现 `Command` 模式（撤销/重做），完善 UI 交互（颜色/线宽）。
4. 
**Week 4**: 编写单元测试，整理 AI 日志，撰写项目报告（含伦理反思）。